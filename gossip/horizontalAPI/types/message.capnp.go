// Code generated by capnpc-go. DO NOT EDIT.

package types

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
)

// Represents a generic message on the horizontalApi. Messagetype and length is done by capnproto somehow.
type Message capnp.Struct
type Message_body Message
type Message_body_Which uint16

const (
	Message_body_Which_push      Message_body_Which = 0
	Message_body_Which_connChall Message_body_Which = 1
	Message_body_Which_connPoW   Message_body_Which = 2
	Message_body_Which_connReq   Message_body_Which = 3
)

func (w Message_body_Which) String() string {
	const s = "pushconnChallconnPoWconnReq"
	switch w {
	case Message_body_Which_push:
		return s[0:4]
	case Message_body_Which_connChall:
		return s[4:13]
	case Message_body_Which_connPoW:
		return s[13:20]
	case Message_body_Which_connReq:
		return s[20:27]

	}
	return "Message_body_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Message_TypeID is the unique identifier for the type Message.
const Message_TypeID = 0xa5588519d0dba97f

func NewMessage(s *capnp.Segment) (Message, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Message(st), err
}

func NewRootMessage(s *capnp.Segment) (Message, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Message(st), err
}

func ReadRootMessage(msg *capnp.Message) (Message, error) {
	root, err := msg.Root()
	return Message(root.Struct()), err
}

func (s Message) String() string {
	str, _ := text.Marshal(0xa5588519d0dba97f, capnp.Struct(s))
	return str
}

func (s Message) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Message) DecodeFromPtr(p capnp.Ptr) Message {
	return Message(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Message) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Message) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Message) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Message) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Message) Body() Message_body { return Message_body(s) }

func (s Message_body) Which() Message_body_Which {
	return Message_body_Which(capnp.Struct(s).Uint16(0))
}
func (s Message_body) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Message_body) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Message_body) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Message_body) Push() (PushMsg, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != push")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return PushMsg(p.Struct()), err
}

func (s Message_body) HasPush() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Message_body) SetPush(v PushMsg) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPush sets the push field to a newly
// allocated PushMsg struct, preferring placement in s's segment.
func (s Message_body) NewPush() (PushMsg, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewPushMsg(capnp.Struct(s).Segment())
	if err != nil {
		return PushMsg{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Message_body) ConnChall() (ConnChall, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != connChall")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return ConnChall(p.Struct()), err
}

func (s Message_body) HasConnChall() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Message_body) SetConnChall(v ConnChall) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewConnChall sets the connChall field to a newly
// allocated ConnChall struct, preferring placement in s's segment.
func (s Message_body) NewConnChall() (ConnChall, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewConnChall(capnp.Struct(s).Segment())
	if err != nil {
		return ConnChall{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Message_body) ConnPoW() (ConnPoW, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != connPoW")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return ConnPoW(p.Struct()), err
}

func (s Message_body) HasConnPoW() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Message_body) SetConnPoW(v ConnPoW) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewConnPoW sets the connPoW field to a newly
// allocated ConnPoW struct, preferring placement in s's segment.
func (s Message_body) NewConnPoW() (ConnPoW, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewConnPoW(capnp.Struct(s).Segment())
	if err != nil {
		return ConnPoW{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Message_body) ConnReq() (ConnReq, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != connReq")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return ConnReq(p.Struct()), err
}

func (s Message_body) HasConnReq() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Message_body) SetConnReq(v ConnReq) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewConnReq sets the connReq field to a newly
// allocated ConnReq struct, preferring placement in s's segment.
func (s Message_body) NewConnReq() (ConnReq, error) {
	capnp.Struct(s).SetUint16(0, 3)
	ss, err := NewConnReq(capnp.Struct(s).Segment())
	if err != nil {
		return ConnReq{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Message_List is a list of Message.
type Message_List = capnp.StructList[Message]

// NewMessage creates a new list of Message.
func NewMessage_List(s *capnp.Segment, sz int32) (Message_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Message](l), err
}

// Message_Future is a wrapper for a Message promised by a client call.
type Message_Future struct{ *capnp.Future }

func (f Message_Future) Struct() (Message, error) {
	p, err := f.Future.Ptr()
	return Message(p.Struct()), err
}
func (p Message_Future) Body() Message_body_Future { return Message_body_Future{p.Future} }

// Message_body_Future is a wrapper for a Message_body promised by a client call.
type Message_body_Future struct{ *capnp.Future }

func (f Message_body_Future) Struct() (Message_body, error) {
	p, err := f.Future.Ptr()
	return Message_body(p.Struct()), err
}
func (p Message_body_Future) Push() PushMsg_Future {
	return PushMsg_Future{Future: p.Future.Field(0, nil)}
}
func (p Message_body_Future) ConnChall() ConnChall_Future {
	return ConnChall_Future{Future: p.Future.Field(0, nil)}
}
func (p Message_body_Future) ConnPoW() ConnPoW_Future {
	return ConnPoW_Future{Future: p.Future.Field(0, nil)}
}
func (p Message_body_Future) ConnReq() ConnReq_Future {
	return ConnReq_Future{Future: p.Future.Field(0, nil)}
}

const schema_d06424cd5634d6a3 = "x\xda\xc4\x95]h\x1cU\x14\xc7\xcf\xb9\xb3\xd9IB" +
	"\x96d\x98\x04Zl\x99k\xa9`\xa3\xe9\x87\xed\x8b\xa1" +
	"\x906\x15\xfc\x80@f\xd3\x9a\xa0\xa4\xed\xcd\xceMf" +
	"p2w23\xdbu\x0b\xa5 \x0a*V\xa4\"\xb6" +
	"T\xa9\xb4*\x06\x14\x84\xbe\xf8A\x85\x16\x04i\x09\x14" +
	"\xd1>(\x85F(\xd6\x0a\x0a\xbe\x88b{\xe5\xceL" +
	"\xb61\xac\xab\xf5\xc5\xc7\x9d{\xf7\xfc\xcf\xf9\xdf\xdf9" +
	"g\xf3\x0bdGaKiS\x1b\x10{{[Q>" +
	"M.\x0e|\xf1\xf3\xcb\xa7\xc1\xbe\x0bQ\xf6\x1c\x1c9" +
	"\xd1\xfb\xfc\xf1\x93\xd0\x86:\xc0\xd6C\xa4\x1f\xcd#D" +
	"7\x8f\x10\xcb\\ 5@yx\xfe\xdbK\xab\x9f\x9b" +
	"x\x07\xec^Dy\xfa\xf2\xb6\xc7\x17\xd6;\x97\xb2\xfb" +
	"\xe6\x9b\xdaw\xe6\xbc\xa6\x9b\xf3\x9ae\xfe\xa6\x0d\x01\xca" +
	"s\xaf\xbfr\xe8\xc7\xf6\xc7\xce\x80\xdd\x87({\xaf\xfc" +
	"p\xeb\xdc\xbb\xd7\x8e\xe6\xd7oj7\xcc\x8e\x82nv" +
	"\x14,sgAE\xdf\xfa\xe1g\xf1\xf5\x8b\xf7\x9c\x07" +
	"{\x0d.\xd3\xda\x83:\x16\x00\xb6\x96\xda:\x11\xd0\xec" +
	"k\xfb\x1eP>\xf8\xf1b\xe7\xc4}\xeb\x16\xc06\x10" +
	"\xe5\xa7\xeb\xe4O{\xee\x9e\xb8\x9e\x87\xfe\xbax\xc1\\" +
	",\xea\xe6b\xd12\xfbtu\xdd\xef\xfb\xf5\xd0\xb6g" +
	"\xf950V\xa3\x9c{\xf8\xccGW\xf7\x9e8\x05\x05" +
	"U\xe6\xd9\xf6N4\x17\xdaus\xa1\xdd\x02.\x93z" +
	"\xc8\xe3M\x15\xa1\x05\xc1\xbe\x8a\xcb|\x9f\x073|c" +
	"\x85\x85A8\xb8K\x04\xc1\xaen\xf5q\x14\xd1. " +
	"\x91{_=i\x9f\xbd\xfc\xe2\xe7`\x17\x08\xee\xdc\x8c" +
	"\xd8\x05\xb0\x05\x07\x89,\xf38\x14\x81C\xf5\x9a\x97\xb8" +
	"\x94\xd1\x80\xd7h#\x1c\x9d\x16\x11M\\N\xbd\xc0K" +
	"<\xe6\xd3Q1NE\x90~rE\xe4\x1d\x14A2" +
	"\xc4\xfc\x9d\xa1\xb7\x11\xc0n\xd7\x0a\x00\x05\x0406\x94" +
	"\x8d\x01\xcb\x9e\xd0\xd0v\x08\"\xf6\xa2\xfa\xc8\x06\x0df" +
	"\xd9ohh\xbfGP.i\x00\xf2&\x09\xaeI\x13" +
	"4\xf0\x86d\x95\xa4\xca|Z!+s\xeaV\xc9\x00" +
	"`\x07\x10\xec\x00\x1c\xaa\x08\xf1\x94\xd7,\xd6\xfdy\xb1" +
	"\x17P\xf2\xa0\x12\xd5\xc3\x84\x17\x1d\xea\xb0\x84\xd1j\xcc" +
	"\x1d\xca\x92\xb4\x9e(3\x82G4\x11\xf4\x00\xf3=\x87" +
	"%<=Q:\x88% X\x02\xcc}\x9f\xe5$\x8e" +
	"Y\xc3\xf0\x11\x1e\xc7:\x9b\xe1\xcd\xed\xde\x91g0\xac" +
	"\xc92\x0f#\x1e\xf3\xa0+\x89)\xa33<\xe0\x91W" +
	"\xa1\xb3<\x0d\xb6\xd2\xda\xccY:\x92\x9d*a\xca\x02" +
	"\x87*\x1b\x12\x97z1uD\xc0\xe9T\x9d\xa6ID" +
	"\"\x114\x16\xb3\xdc\x15\xb5\x8d\x00`\x17\xd4{\xe02" +
	"\\\x8dR?\x90\xee)\xe1\xd4\x1b\xf4\x90 \xd8\x17\x8a" +
	"\xdamn\xba\x83Q1\xde\xbc\x8c{\xf32>A9" +
	"\xc6\x03G\xa5\xda\x96\x12\xf1_)y\xc0\xd8`\xd9\xbb" +
	"5\xb4\xf7\xdf\xa6dr\xd0\x98\xb4\xecc\x1a\xdao\x13" +
	"\xb4\x02\x11TZ\xf1\xf1\x8dLo\xd0\x9aK\xbc\x8aK" +
	"c\xe1\x1f\xe0q\xf6h\xda\xffJ\x87\xb6\x92\x0e\xf5K" +
	"9\x0f`\xf7h\x85.)S\x0bX\xbf\xea\x89\x974" +
	"\xb4\x8f\x11,\xe1-\x99\x99\xf0Z\xd98n\xd9_i" +
	"h_%X\"7e/\x12\x00\xe3\xca\xb0q\xc5\x1a" +
	"\xebE\x0d\xc7(\x12,i\x7f\xc8^\xd4\x00\xcc\xb58" +
	"l\xaeEkl\xb7:\xda\x8f\x04\xbb\xc3j\xec\xb6\xf0" +
	"\xedw\xb9\x84\x1c\xf1\x14\x88O\x8eVcw$\x9e\x99" +
	"\xa4\xb3C\xd9\x01\x00\xf6\xdc\x1e^\x80\xd8\x03(+j" +
	"\xae\xb8\xcc\x07\xf4[X\xf9%6\xa2\x17\xb3\xe8\xbb\xf2" +
	"\xff\xf9\x93\x0d\xd4Ss\xbd Y\x01\x0e\x8e\xa7\xc2\x8d" +
	"y\x9f\x09\x1fV\xc2\xa3b\xbc\x05\x94\xe7\x9b\x8a\x8e\x8a" +
	"\xf1\x7f\x94\x1c\x87T\xb2\xb1\x03\x96I\x96\xf9\xdc\x1dK" +
	"\x96\xf9\xdc\xbf\x95l\x0c\xfb\xdc\xde\x0c\x9e\xb0Jb7" +
	"''\x7f\x16\x80\xe6\x1d\xb9>\xcf\xe4\x19l\x0c\x96\xb6" +
	"t\xb0\xa8\xe7o=U \x031oE\xb6Nq\xf8" +
	"\x96\x86\xf6\xfb\x04\x8d\xa5^\x9c\x7f\xc2\xf8\xa0\x81\xa1A" +
	"HNa\xd9X\xb4\xc6\xba\x14j\xab\x90 j\x19\x83" +
	"}8l\xf6\xa15\xb6]\x1d<\x82\x04\xf5$\xf1[" +
	"\xec\x9e~\"\x13o\x96\x0f$b@\xf7\xbd\x03|\x90" +
	"\xba\xa2FgYP\xa7\xd3\xd5(qyD]\x11\xc6" +
	"4vE\xd5O\x87M\xa3\xa0)N\xc3H\x84l\xa6" +
	"\x9b%\xdc\x01\xc0\"\x10,\x02\xca\x19\x11\xc7^\xb8\xbb" +
	"\x0eZ\xd8\xac\xd7W\xe5\xf4\x9fJ\x9d\xa6b\x9a\xa2\x0a" +
	"\x1b\xb2\xba\xaf\x0b\xa6\x02\xe9@P\x87\xc6\xbb>\x0a\xf8" +
	"P\x8b.\xfaEz\x0e\x0f\x12o\xda#\x15\x96x\"" +
	"P!\xb3D\xad\xa5&\xca#\x1eV\"\x829-\xb2" +
	":*Y4\xe5%\x11\x8b\xb0N\xb3\xeb\xa8r\xfa\xeb" +
	"h\xc9\x16~\xc4\xe7\xaa<N\x96\xad\xfb2\x9f\xfb;" +
	"J\x96\x1c\xefT\xdb>\xfd\x9f\xa7\x073\x94\xdd\xd9\x9e" +
	"\xcf\xb1\xc1?\x03\x00\x00\xff\xffd\xdc\xe2\xa3"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_d06424cd5634d6a3,
		Nodes: []uint64{
			0xa38eefc82dcb0278,
			0xa5588519d0dba97f,
			0xb34a08eb7d9097c1,
			0xc225cbe873beb033,
			0xcd222b580ae1b939,
			0xe56584347df7156c,
		},
		Compressed: true,
	})
}
