// Code generated by capnpc-go. DO NOT EDIT.

package types

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
)

// Represents a generic message on the horizontalApi. Messagetype and length is done by capnproto somehow.
type Message capnp.Struct
type Message_body Message
type Message_body_Which uint16

const (
	Message_body_Which_push      Message_body_Which = 0
	Message_body_Which_connChall Message_body_Which = 1
	Message_body_Which_connPoW   Message_body_Which = 2
	Message_body_Which_connReq   Message_body_Which = 3
)

func (w Message_body_Which) String() string {
	const s = "pushconnChallconnPoWconnReq"
	switch w {
	case Message_body_Which_push:
		return s[0:4]
	case Message_body_Which_connChall:
		return s[4:13]
	case Message_body_Which_connPoW:
		return s[13:20]
	case Message_body_Which_connReq:
		return s[20:27]

	}
	return "Message_body_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Message_TypeID is the unique identifier for the type Message.
const Message_TypeID = 0xa5588519d0dba97f

func NewMessage(s *capnp.Segment) (Message, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Message(st), err
}

func NewRootMessage(s *capnp.Segment) (Message, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Message(st), err
}

func ReadRootMessage(msg *capnp.Message) (Message, error) {
	root, err := msg.Root()
	return Message(root.Struct()), err
}

func (s Message) String() string {
	str, _ := text.Marshal(0xa5588519d0dba97f, capnp.Struct(s))
	return str
}

func (s Message) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Message) DecodeFromPtr(p capnp.Ptr) Message {
	return Message(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Message) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Message) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Message) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Message) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Message) Body() Message_body { return Message_body(s) }

func (s Message_body) Which() Message_body_Which {
	return Message_body_Which(capnp.Struct(s).Uint16(0))
}
func (s Message_body) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Message_body) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Message_body) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Message_body) Push() (PushMsg, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != push")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return PushMsg(p.Struct()), err
}

func (s Message_body) HasPush() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Message_body) SetPush(v PushMsg) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPush sets the push field to a newly
// allocated PushMsg struct, preferring placement in s's segment.
func (s Message_body) NewPush() (PushMsg, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewPushMsg(capnp.Struct(s).Segment())
	if err != nil {
		return PushMsg{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Message_body) ConnChall() (ConnChall, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != connChall")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return ConnChall(p.Struct()), err
}

func (s Message_body) HasConnChall() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Message_body) SetConnChall(v ConnChall) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewConnChall sets the connChall field to a newly
// allocated ConnChall struct, preferring placement in s's segment.
func (s Message_body) NewConnChall() (ConnChall, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewConnChall(capnp.Struct(s).Segment())
	if err != nil {
		return ConnChall{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Message_body) ConnPoW() (ConnPoW, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != connPoW")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return ConnPoW(p.Struct()), err
}

func (s Message_body) HasConnPoW() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Message_body) SetConnPoW(v ConnPoW) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewConnPoW sets the connPoW field to a newly
// allocated ConnPoW struct, preferring placement in s's segment.
func (s Message_body) NewConnPoW() (ConnPoW, error) {
	capnp.Struct(s).SetUint16(0, 2)
	ss, err := NewConnPoW(capnp.Struct(s).Segment())
	if err != nil {
		return ConnPoW{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Message_body) ConnReq() (ConnReq, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != connReq")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return ConnReq(p.Struct()), err
}

func (s Message_body) HasConnReq() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Message_body) SetConnReq(v ConnReq) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewConnReq sets the connReq field to a newly
// allocated ConnReq struct, preferring placement in s's segment.
func (s Message_body) NewConnReq() (ConnReq, error) {
	capnp.Struct(s).SetUint16(0, 3)
	ss, err := NewConnReq(capnp.Struct(s).Segment())
	if err != nil {
		return ConnReq{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Message_List is a list of Message.
type Message_List = capnp.StructList[Message]

// NewMessage creates a new list of Message.
func NewMessage_List(s *capnp.Segment, sz int32) (Message_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Message](l), err
}

// Message_Future is a wrapper for a Message promised by a client call.
type Message_Future struct{ *capnp.Future }

func (f Message_Future) Struct() (Message, error) {
	p, err := f.Future.Ptr()
	return Message(p.Struct()), err
}
func (p Message_Future) Body() Message_body_Future { return Message_body_Future{p.Future} }

// Message_body_Future is a wrapper for a Message_body promised by a client call.
type Message_body_Future struct{ *capnp.Future }

func (f Message_body_Future) Struct() (Message_body, error) {
	p, err := f.Future.Ptr()
	return Message_body(p.Struct()), err
}
func (p Message_body_Future) Push() PushMsg_Future {
	return PushMsg_Future{Future: p.Future.Field(0, nil)}
}
func (p Message_body_Future) ConnChall() ConnChall_Future {
	return ConnChall_Future{Future: p.Future.Field(0, nil)}
}
func (p Message_body_Future) ConnPoW() ConnPoW_Future {
	return ConnPoW_Future{Future: p.Future.Field(0, nil)}
}
func (p Message_body_Future) ConnReq() ConnReq_Future {
	return ConnReq_Future{Future: p.Future.Field(0, nil)}
}

const schema_d06424cd5634d6a3 = "x\xda\x94Um\x88\x15\xd5\x1b\x7f\x9e3w\xef\xac\xcb" +
	"^v\x87\xb9\x0b\xca_\x99\xf3\x17\x83\xdc|M?\xe4" +
	"\"\xac\xaeI/\xb0p\xe7\xaev\xadX\xf5\xec\x9d\xb3" +
	"w\x86f\xe7\xcc\xce\xcc\xf5v\x85E\x88\x82\x88\x8c0" +
	"$\xcd\x0f\x86f \x14$~\xe9\x85\x02\x85 \x14A" +
	"\"\xfcP,h YAA_\x82(O\xcc\xcb\x8e" +
	"\x8b\xden\xed\xc79\xe7\x99\xe7\xf7\x9c\xdf\xef\xf7<\xcf" +
	"&\x9f\xec(l.m\xec\x01bn\xef)\xca\x17\xc9" +
	"\xd5\xf5_\xfd\xfa\xc6Y\xd0\xfe\x87r\xf0\xf0\xf8\xa9\xf2" +
	"\xab'OC\x0f\xaa\x00[\xe6\xc80\xeaG\x89\xaa\x1f" +
	"%\x86~\x8d\x8c\x02\xca#\xe7\xbf\xbb\xbe\xe2\x95}\xe7" +
	"\xc0,#\xca\xb37\xb6>sm\x8du=\x8d\xd7\xb7" +
	")\xdf\xeb\xbb\x15U\xdf\xad\x18\xfaq%\x0e\xbf\xf4\xf6" +
	"\x9bs?\xf7>}\x11\xcc!DY\x9e\xff\xf1\xee\xa5" +
	"\xf7o\x1f\xcb\xc2O*?\xe9\xe7\x14U?\xa7\x18\xfa" +
	"\xbc\xd2\x02\x94[>\xfa\"\xbcs\xf5\xa1\xcb`\xae\xc4" +
	"EX{Q\xc5\x02\xc0\x96\xf3\x85>\x04\xd4/\x14~" +
	"\x00\x94\xdb>\xb9\xd5\xb7\xef\x91\xd5\xd7\xc0\xd4\x10\xe5g" +
	"\xab\xe5/{\xff\xbf\xefN\x96z\xb6xE\x9f+\xaa" +
	"\xfa\\\xd1\xd0/\x14\xe3pw\xe8\xf7\xb9\xad/\xf3\xdb" +
	"\xa0\xad@9\xfb\xc4\xc5\x8fo\xee?u\x06\x0a\xf13" +
	"\x9f\xed\xedC\xdd\xe9Uu\xa7\xd7\x00.\xa3\xb6\xcf\xc3" +
	"\x8du\xa1x\xde\x81\xba\xcd\\\x97{\x0d\xbe\xa1\xce|" +
	"\xcf\x1f\xd9%<o\xd7@|XA4\x0bH\xe4\xfe" +
	"\xb7N\x9b\x9f\xdfx\xedK0\x0b\x04wnB\xec\x07" +
	"\xd8\x8c#DVy\xe8\x0b\xcf\xa2j\xcb\x89l\xca\xa8" +
	"\xc7[4OG\xa7E@#\x9bS\xc7s\"\x87\xb9" +
	"\xb4\"jTx\xc9\x91-\x02\xe7\xb0\xf0\xa2Q\xe6\xee" +
	"\xf4\x9d\x0d\x00fA)\x00\x14\x10@+\x8dh%\xc3" +
	"\xdc\xa3\xa0y\x90\xe0h]\x88\x17\x1c\xde\xa1\x8c\xc7\xb2" +
	"2\xde!\x92{\xf5\xa0\xedG|\x99E-\x161\xda" +
	"\x0c\xb9EY\x94 \x05i\x89<\xa0\x91\xa0\x87\x98\xeb" +
	"X,\xe2\xc9ME\xd4\xd6Q\xe6\x86\x82\x86<8\xc4" +
	"C\xca\xc2\x85\xe2\x95\x06\x07\xc0\x12\x10,\x01fd\xcd" +
	"p\x12\x86,gi\x9c\x87\xa1\xca\x1a\xbc3G;\xb2" +
	"\xe2\xc6\x14Y\xe5~\xc0C\xee\xf5G!e\xb4\xc1=" +
	"\x1e8u:\xc3\x93d\xf7\xf3\x91\xd2A\xc7\xd3\xdb\x18" +
	"\x982\xcf\xa21\x9f\x91M\x9d\x90Z\xc2\xe3t\xaaM" +
	"\x93\"\x02\x11\x09\x1a\x8a\x19n\x8b\xd6\x06X \x11\x17" +
	"yL+\x0d\x03\x19\x98\x12V;\x97\x9cx\xde\x01_" +
	"\xb4\xee\x89=\xe0UD\xad\xf33\x1e\xce\x9e\xf1)\xca" +
	"\x09\xeeYq\xa9=\x89\x8cK\x92\xb67\x97v\xed\xa3" +
	"\xda\xda\\Z\xc42\xc6\x87\x93#\xda\xa4a\x9eP\xd0" +
	"|\x8f\xa0\xe1\x09\xaf\xdeI\xee\x95I)\x1a~+\x93" +
	"\x08\xda\xb2\x89S\xb7i(\xdcX\xbaDOE\xd4\x00" +
	"p\x19\x10\\\x06]\x8c\xb3.{\xd4\x15\xcc\x8dS\\" +
	"\xaaq\x00\x1fp\x87r\xbf;\xe2\xaf\x98y\x00sP" +
	")\xf4K\x99P\xc0\x865f\x98\xaf+h\x9e X" +
	"\xc2\xbb2%\xe1xU;i\x98\xdf(h\xde$X" +
	"\"\x7f\xc92\x12\x00m~L\x9b7&\xca\xa8\xe0\x04" +
	"E\x82%\xe5OYF\x05@_\x85c\xfa*4&" +
	"\xf6\xc4W\x07\x91\xe0\x80\xdf\x0c\xed.\xbc\xfd!\x17," +
	"G\x9c\xd8\x88\xcfW\x9a\xa1=\x1e6&\xe9\xcchz" +
	"\x01\x80\x83\xf7&\x0e \x0e\x02\xcaz<\x0cl\xe6\x02" +
	"\xba]\xa8\xfc\x1a\xf3\xec\xc54\xfb\xae\xec?w2\xb7" +
	"zB\xae\xe3E\xf7\x19\x07k\x09p>\xa3S\xe0#" +
	"1pE\xd4\xba\x98\xf2rG\xd0\x8a\xa8\xfd+d\x0d" +
	"\x12\xc8|p/\x82\xac\xf2\xd9%CV\xf9\xec\x7f\x85" +
	"\xcc'tFoj\x1e\xbfIB;sN&\x0b@" +
	"\xe7\x8e\\\x93U\xf2\x12\xe6\x83\xa5'\x19,\xb1\xfc\xdd" +
	"\xa7\x0a\xa4F\xccZ\x91\xad\x8e}\xf8\xae\x82\xe6\x07\x04" +
	"\xb5\x85^<\xff\x9c\xf6anC\x8d\x90\xcc\x85U\xed" +
	"\x961\xd1\x1f[m9\x12D%\xf5\xe0\x10\x8e\xe9C" +
	"hLl\x8f/\x9eD\x82j\x14\xb9]\x16\xc60\x91" +
	"\x913\xc3\xd7Gb\xbd\xea:\x87\xf8\x08\xb5E\x8b\xce" +
	"0\xafM\xa7\x9bAd\xf3\x80\xda\xc2\x0fih\x8b\xa6" +
	"\x9b\x0c\x9b\xfcAS\x9c\xfa\x81\xf0Yc\x80E\xdc\x02" +
	"\xc0\"\x10,\x02\xca\x86\x08C\xc7\xdf\xd3\x06\xc5\xef\xd4" +
	"\xeb\xcb3\xf7\x9fI\x98\xa6b\x9ab\x9c\xd6gmW" +
	"\x15,N\xa4\x02A\x15r]\x9f\x02|\xbcK\x17\xfd" +
	"&\x1d\x8b{\x913\xed\x90:\x8b\x1c\xe1\xc5)\xd3B" +
	"\x8d\x85&\xca2\x1e\x89A\x04\xb3\xbaTuL\xb2`" +
	"\xca\x89\x02\x16`\x9b\xa6\xe1h=\xb0x\xd2-\x1d\xf0" +
	"\xd9&\x0f\xa3E;\xba\xcag\xff\xc9%\x0b\x8c\xf7\xc5" +
	"+:\xf9\xcfQ\xbd\x06eK[\xce\x99m\xf0\xef\x00" +
	"\x00\x00\xff\xff\xfb;\xcf3"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_d06424cd5634d6a3,
		Nodes: []uint64{
			0xa38eefc82dcb0278,
			0xa5588519d0dba97f,
			0xb34a08eb7d9097c1,
			0xc225cbe873beb033,
			0xcd222b580ae1b939,
			0xe56584347df7156c,
		},
		Compressed: true,
	})
}
