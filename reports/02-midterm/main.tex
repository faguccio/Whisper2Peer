\documentclass[a4paper,english,10pt,NET]{tumarticle}

\usepackage[svgnames]{xcolor}

% TUM packages
\usepackage{tumfonts}
\usepackage{tumarticle}
\usepackage{tumlocale}
\usepackage{tumcmd}

\usepackage{graphicx}
\usepackage[style=american]{csquotes}
\usepackage{hyperref}
\usepackage{xspace}

\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{pdflscape}

\usepackage{siunitx}
\usepackage{todo}

\usepackage{cleveref}

\usepackage{tikz}
\usepackage{messagepassing}
\usepackage{bytefield}
\usetikzlibrary{arrows.meta,calc,fit,positioning,decorations.pathmorphing,automata,shapes}
\tikzset{
	>={Stealth[scale=0.7]},
	every edge/.style={>={Stealth[scale=0.7]},draw,},
	automata/.style={
		->,
		every edge/.style={>={Stealth[scale=1.3]},font=\footnotesize,shorten >=1pt,draw,},
		font=\small,
		initial text={},
		every state/.style={draw=TUMBlue,very thick,fill=TUMLightBlue,ellipse,},
		every loop/.style={looseness=5,},
		node distance=1.8cm and 2.3cm,
	},
}

\definecolor{Type}{HTML}{FF7700}
\definecolor{Interface}{HTML}{B4A7E5}
\colorlet{Struct}{Aquamarine}
\NewDocumentCommand{\PumlCircle}{mm}{\tikz[baseline=(n.base)]\node[inner sep=0.07em,circle,fill=#1,draw=black] (n) {\texttt{#2}};}

\renewcommand{\eg}{\mbox{e.\,g.}\xspace} % already defined in tumcmd but without xspace
\renewcommand{\ie}{\mbox{i.\,e.}\xspace} % already defined in tumcmd but without xspace
\newcommand{\cf}{\mbox{c.\,f.}\xspace}
\newcommand{\tos}{$\to$\xspace}
% TODO message passing vs messagepassing
% TODO verticalAPI horizontalAPI
% TODO reference (footnote) to capnproto
% TODO thread ~ goroutine
% TODO talk about the actual gossip strategy?

% Set document title. If no language is supplied, the document language is
% assumed.
\title{P2Psec Project -- Midterm Report}
\author{Fabio Gaiba, Lukas Heindl}
\date{July 2nd, 2024}

\begin{document}

\maketitle
\thispagestyle{tumarticle}

\section{Introduction}
% TODO(no one for now)

Let's remember the team name \textbf{Whisper2Peer} :)

\Todo{write later, summary of the rest, not strictly needed but would be nice}

\section{Changes to initial assumptions}
% TODO(Fabio)

\Todo{no substantial changes but few minor ones: no gitlab CI (see moodle), no git hooks yet}

\section{Module Architecture}
% TODO(Fabio)

\Todo{describe highlevel overview}
\begin{figure}
	\centering
	\input{figures/overview}
	\caption{A high level overview of the modules and the channels.}
	\label{fig:overview}
\end{figure}

\subsection{Logical structure}
Using UML class diagrams is the standard way of modeling the logical structure of a project (at least with object orientation).
It quickly shows how classes are connected\,/\,coupled and what data a class stores.

The UML class diagram for the packages of our project can be seen in \cref{fig:classDia}.
The \PumlCircle{Struct}{S} marks a struct/class, the \PumlCircle{Interface}{I} marks inferfaces and the orange \PumlCircle{Type}{T} marks a type.
Types (as marked with \PumlCircle{Type}{T}) usually are simple type aliases for an existing class (or a builtin type of golang).
Note that for a better overview, this diagram is mostly structured like \cref{fig:overview} with the verticalAPI on the left and the horizontalAPI on the right.

In our case most of the communication is not done by function calls but by message passing.
Thus, there are less functions defined on our classes than one might expect and those present are more general like \texttt{Listen} or \texttt{run}.
To gain a deeper understanding about the internal communication please refer to \cref{sec:msgpassing}.
Still, getting a rough overview of what class implements which interface is also usefull for the message passing.
For message passing we need to focus on the interfaces starting with \texttt{To\ldots} and \texttt{From\ldots}.
As sum-types\,/\,unions are not natively supported by golang, we use these interfaces as a workarround (and the \emph{go-sumtype}\footnote{\url{https://github.com/BurntSushi/go-sumtype}} tool for checking.
Then, on the golang channels we send objects of the respective interface type.

In \cref{sec:structureNetworking} we will go more into detail regarding the networking part.
For now it is only important that while we implement de- and serialization on the verticalAPI ourself, we use capnproto on the horizontalAPI for this task.
The respective logic in both cases is contained in the respective \texttt{types} subpackage.
Since the capnproto code is generated automatically (and contains some capnproto internals), we obmit the \texttt{horizontalAPI/types} subpackage while including the \texttt{verticalAPI/types} subpackage.

Also note that golang does not have the concept of constructors for a class.
Therefore, data needed\,/\,used for initialization of the classes is not visible in the class diagram.
In most cases the constructor is pretty straight forward.
The \texttt{strategy} package is an exception to this.
Here there is only one generic constructor \texttt{New} which returns an object which implements the \texttt{StrategyCloser} interface (at the moment this is only the \texttt{dummyStrat}).
Which strategy is to be used is decided by the generic constructor based on the arguments.

One additional special case might be the \texttt{common} package.
First this was contained in the \texttt{verticalAPI/types} package but as we progressed, we figured it would be a good idea to extract the definition of some message types we use throughout the whole module.
This way we avoid the necessety to include the \texttt{verticalAPI/types} package everywhere.

\begin{landscape}
	\pagestyle{empty}
	\begin{figure}
		\centering
		\hspace*{-0.1\linewidth}\includegraphics[width=1.2\linewidth]{figures/class}
		\caption{Class diagram for the packages included in our project, generated by PlantUML.}
		\label{fig:classDia}
	\end{figure}
\end{landscape}

\subsection{Process architecture} \label{sec:msgpassing}
% TODO(Fabio)

\Todo{come up with scenario (reg, announce \quad|\quad notify > validation) to explain message-passing}
\Todo{figure for message types on different channels}

\begin{figure}
	\centering
	\input{figures/sequence}
	\caption{Messagepassing of one instance/scenario.}
	\label{fig:msg}
\end{figure}

% \begin{figure}
% 	\centering
% 	\input{figures/fsm_msgs}
% 	\caption{Finite state machine for message caching.}
% 	\label{fig:fsm_msgs}
% \end{figure}

threading, multi-process, ... (a lot of intersection with the classes, but I think here we can go in depth about the communication part)

\subsection{Networking} \label{sec:structureNetworking}

For the networking, first we need to differentiate between the two APIs our module has.
First, the verticalAPI and second the horizontalAPI.

\subsubsection{verticalAPI}
On the verticalAPI we communicate with other modules running on the same peer.
At this point, these modules are implemented by someone else (\eg another team in the lecture).
Therefore, we were handed a specification which defines the format of the messages on that API.
With the hard requirement to adhere to this specification it is not possible for us to use capnproto at this point so we need to implement the de-\,/\,parsing on our own.
If you have a look back at the class diagram in \cref{fig:classDia} again, this is implemented in the \texttt{verticalAPI/types} package.

\subsubsection{horizontalAPI}
On the other side we have the horizontalAPI which is only used for our module to communicate with the same module running on another peer.
As a result, we are completely free to come up with a custom message format on this API.
In our case we decided to use capnproto as a library which does the de-\,/\,parsing for us.
Analog to the verticalAPI, the code generated by capnproto is placed in the \texttt{horizontalAPI/types} package.

\subsubsection{both API-modules}
Apart from the difference in the message formats and the de-\,/\,parsing both, the horizontalAPI and the verticalAPI, modules are quite similar.
Both modules use two threads, one for reading from and one for writing to the socket, per connection in addition to the one thread used to establish (and dispatch) new connections.
Thereby, they both provide a layer of abstraction on top of the raw tcp sockets where other threads can simply send a message on the respective golang channel and (try to) receive from the golang channel in the other direction.

Especially for reading having the golang channel is nice since we can make use of golang's builtin \texttt{select} statement when waiting for messages on multiple interfaces.
For writing this approach is not strictly necessary.
Still having a dedicated thread and the golang channel for communication allows us to send the message to the API-module and continue execution without waiting until the message actually was sent on the network connection.

In general this architecture also allows us to have multiple listening (read) and multiple writing threads connected to the API-module.
Since we did not need it so far, we did not implement having multiple listening threads.
Also note how this use of one thread per read\,/\,write on the connection combined with the communication via golang channels implicitly synchronizes the write operations (althoug in golang this is not strictly necessary to be done manually).


\section{Security Measures}
% TODO(Fabio)

\Todo{not in place, but put some thought into it (PoW for participation) \tos \cf future work}

E.g secure channels between peers, sybil resistance mechanism, concurrent lookup paths in DHT protocol, . . . 

You should briefly describe the intention behind the security measure and how you want to implement it


\section{Specification of the peer-to-peer protocol}
This module works with two protocol, one on the verticalAPI and one on the horizontalAPI.
The one for the verticalAPI was already predetermined, its specification can be found in the \emph{specification.pdf} document.
For the other one we had the freedom to develop something on our own.
To avoid having to write the de-\,/\,parsing ourself, we chose to use capnproto.
Capnproto is a data serialization format which comes with libraries in multiple different languages.
With capnproto you only specify what data (\enquote{name} and type) should be in the message.
The concrete message format is then the concern of capnproto.

With this in mind, it makes no real sense to include the conrete format of the messages but only the names of the fields and their type.
As of now we only have one message type on the horizontalAPI, namely the \emph{push} message type.
Its fields and types can be seen in \cref{tab:push}.
This message type is used to actively send information to the neighboring peers.

The actual message sent on the horizontalAPI is not the raw \emph{push} message type but a more generic message type which is a simple union of all message types that can be sent on the horizontalAPI.
At the moment there is only the \emph{push} message type but having in mind what we have planned, we will need more in the future (\cref{sec:future})
This approach makes is possible to add more message types as we go by simply adding more types to this union.
The nice thing at this point is that capnproto handles the complete checking which message type was actually sent (resolving the union so to speek).
This way we do not need to come up with \eg a messageType field on our own and assign identifieres for the individual types.

\begin{table}
	\centering
	\input{figures/hzMsgs_push}
	\caption{Contents of a push message.}
	\label{tab:push}
\end{table}

\section{Future Work} \label{sec:future}
\begin{itemize}
	\item currently only unit tests \tos end to end tests would be nice to test if everything works well together. Plan on using a simple network (for which we can make assumptions which nodes should/have to receive the message), start up the peers and instruct one node on the verticalAPI to spread a message
	\item this end to end testing already lays the foundation for larger scale benchmarking of our gossip strategy (test different parameters, use a much larger (randomly generated but fixed for reproducibility) network)
	\item push is not the only strategy which can be used for gossip, we also plan on implementing a pull strategy (which we can benchmark as well and compare the results)
	\item currently no security measures in place, but we plan on implementing one
		\begin{itemize}
			\item when connecting peers have to solve a PoW challenge (sent by the remote peer)
			\item first step in mitigating against sybil attack because attacker is limited by ressources how many peers can join the network (at once). BUT attacker might add nodes one by one and thereby kinda share time-multiplex the ressource
			\item a peer might (and should) request new PoW periodically
			\item thereby this ties the upper limit of sybils an attacker can insert into the network to the ressources the attacker can allocate for its sybils at the same (at least kinda same) time
			\item periodical PoW might be used to DoS a node by requesting PoW over and over again. Thus, nodes should keep track of the point in time of the last PoW request of a neighbor to detect this.
			\item When PoW fails or times out, the connection is silently closed (keeping the connection open but the node does not send/receive data from the connection anymore)
			\item If there still is time left we intend to optimize the PoW further so that a node is not overwhelmed by too many PoW requests
		\end{itemize}
\end{itemize}
% TODO do a subsection for the security part if we go into detail here
% TODO(Lukas)

\section{Workload distribution}
As already outlined, we split our module in various different packages.
This enabled us to distribute the packages and work independently from each other (apart from defining the commmunication\,/\,interface of course).

% TODO(Fabio)
\Todo{Fabio: strategy (peeer programming), vertAPI (testing), main (both)}

Lukas worked on the horizontalAPI and the verticalAPI (from which the common package later was derived).
Note that at least writing the de-\,/\,parsing of the verticalAPI was pretty straight forward because it is fairly similar to what we needed to do for the registration client.

While Fabio started working on the main package, Lukas later did some refactoring and finalized the package.


\todos

\end{document}
