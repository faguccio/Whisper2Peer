\RequirePackage[svgnames]{xcolor}


\documentclass[a4paper,english,10pt,NET]{tumarticle}


% TUM packages
\usepackage{tumfonts}
\usepackage{tumarticle}
\usepackage{tumlocale}
\usepackage{tumcmd}

\usepackage{graphicx}
\usepackage[style=american]{csquotes}
\usepackage{hyperref}
\usepackage{xspace}

\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{pdflscape}

\usepackage{siunitx}
\usepackage{todo}

\usepackage{cleveref}

\usepackage{tikz}
\usepackage{messagepassing}
\usepackage{bytefield}
\usetikzlibrary{arrows.meta,calc,fit,positioning,decorations.pathmorphing,automata,shapes}
\tikzset{
	>={Stealth[scale=0.7]},
	every edge/.style={>={Stealth[scale=0.7]},draw,},
	automata/.style={
		->,
		every edge/.style={>={Stealth[scale=1.3]},font=\footnotesize,shorten >=1pt,draw,},
		font=\small,
		initial text={},
		every state/.style={draw=TUMBlue,very thick,fill=TUMLightBlue,ellipse,},
		every loop/.style={looseness=5,},
		node distance=1.8cm and 2.3cm,
	},
}

\definecolor{Type}{HTML}{FF7700}
\definecolor{Interface}{HTML}{B4A7E5}
\colorlet{Struct}{Aquamarine}
\NewDocumentCommand{\PumlCircle}{mm}{\tikz[baseline=(n.base)]\node[inner sep=0.07em,circle,fill=#1,draw=black] (n) {\texttt{#2}};}

\renewcommand{\eg}{\mbox{e.\,g.}\xspace} % already defined in tumcmd but without xspace
\renewcommand{\ie}{\mbox{i.\,e.}\xspace} % already defined in tumcmd but without xspace
\newcommand{\cf}{\mbox{c.\,f.}\xspace}
\newcommand{\tos}{$\to$\xspace}
% TODO message passing vs messagepassing
% TODO verticalAPI horizontalAPI
% TODO reference (footnote) to capnproto
% TODO thread ~ goroutine
% TODO talk about the actual gossip strategy?

% Set document title. If no language is supplied, the document language is
% assumed.
\title{P2Psec Project -- Midterm Report}
\author{Fabio Gaiba, Lukas Heindl}
\date{July 2nd, 2024}

\begin{document}

\maketitle
\thispagestyle{tumarticle}

\section{Introduction}
% TODO(no one for now)

Let's remember the team name \textbf{Whisper2Peer} :)

\Todo{write later, summary of the rest, not strictly needed but would be nice}

\section{Changes to initial assumptions}
% TODO(Fabio)

For the most part, we committed to our initial proposals. The project is in Golang, with a simple python script that will be used later just for generating networks for end-to-end testing.

\Todo{Check correctness python statement}

As for the used libraries, we sticked to the ones mentioned in the initial report. We have chosen capnproto for the (de)serialization of our custom messages in the Horizontal peer-to-peer communication. 

The majority of the changes in direction regarded the Quality of Software and the Testing parts. While we did leverage \textit{staticcheck} for static checking, we did not get into other checkers such as \textit{golangci-lint}. 

On the other hand we explored the tool \href{https://github.com/BurntSushi/go-sumtype}{https://github.com/BurntSushi/go-sumtype} which allows us compile time checking for sum types, which is not included in the language out of the box. 

Finally, while we have unit testing in place we have not experimented with git hooks yet. The same goes fot Gitlab CI, as it will be put in place for every team later in the project.

\section{Module Architecture}
% TODO(Fabio)

We decided to divide the project into four main packages, plus two support ones. Those main packages are described in the figure \ref{fig:overview}. The following is just a brief overview, each part will be discussed more precisely later in the report.

\begin{itemize}
	\item \textbf{Main}: is in charge of managing the whole module. It has to take and use the configuration parameters, orchestrate the other components and filter and relay messages. Moreover in this package we define the data structure that holds in memory the registered \textit{Gossip Types}.
	\item \textbf{Vertical API}: its main goal is to manage connection to other modules. It provides an abstraction over the networking part and manages under the hood the marshaling and un-marshaling of the messages.
	\item \textbf{Horizontal API}: is very similar to the Vertical API, except it has to communicate with the peer's Gossip modules.
	\item \textbf{Gossip-Strategy}: this package is in charge of instantiating a concrete strategy for disseminating the information between peers. It will leverage the Horizontal API to communicate with peers, focusing just on how to handle the messages.
\end{itemize}

In addition to these four packages, there are also a \textbf{Common} package, holding common data types, and a \textbf{Ringbuffer} package, defining a circular queue data structure used to store data to be spread in the network.  

Those modules will create threads which can communicate with message passing, as can be seen again in the figure \ref{fig:overview}. This design decision allow the program to be highly scalable (due to the parallelization of the threads) and also lightweight (as threads can wait on messages in case there is none to be received).

\Todo{check last paragraph as I am not super sure}

\begin{figure}
	\centering
	\input{figures/overview}
	\caption{A high level overview of the modules and the channels.}
	\label{fig:overview}
\end{figure}

\subsection{Logical structure}
Using UML class diagrams is the standard way of modeling the logical structure of a project (at least with object orientation).
It quickly shows how classes are connected\,/\,coupled and what data a class stores.

The UML class diagram for the packages of our project can be seen in \cref{fig:classDia}.
The \PumlCircle{Struct}{S} marks a struct/class, the \PumlCircle{Interface}{I} marks interfaces and the orange \PumlCircle{Type}{T} marks a type.
Types (as marked with \PumlCircle{Type}{T}) usually are simple type aliases for an existing class (or a built-in type of golang).
Note that for a better overview, this diagram is mostly structured like \cref{fig:overview} with the verticalAPI on the left and the horizontalAPI on the right.

In our case most of the communication is not done by function calls but by message passing.
Thus, there are fewer functions defined on our classes than one might expect, and those present are more general like \texttt{Listen} or \texttt{run}.
To gain a deeper understanding about the internal communication please refer to \cref{sec:msgpassing}.
Still, getting a rough overview of what class implements which interface is also useful for the message passing.
For message passing we need to focus on the interfaces starting with \texttt{To\ldots} and \texttt{From\ldots}.
As sum-types\,/\,unions are not natively supported by golang, we use these interfaces as a workaround (and the \emph{go-sumtype}\footnote{\url{https://github.com/BurntSushi/go-sumtype}} tool for checking.
Then, on the golang channels we send objects of the respective interface type.

In \cref{sec:structureNetworking} we will go more into detail regarding the networking part.
For now, it is only important that while we implement de- and serialization on the verticalAPI ourselves, we use capnproto on the horizontalAPI for this task.
The respective logic in both cases is contained in the respective \texttt{types} subpackage.
Since the capnproto code is generated automatically (and contains some capnproto internals), we omit the \texttt{horizontalAPI/types} package while including the \texttt{verticalAPI/types} package.

Also note that golang does not have the concept of constructors for a class.
Therefore, data needed\,/\,used for initialization of the classes is not visible in the class diagram.
In most cases the constructor is pretty straight forward.
The \texttt{strategy} package is an exception to this.
Here there is only one generic constructor \texttt{New} which returns an object which implements the \texttt{StrategyCloser} interface (at the moment this is only the \texttt{dummyStrat}).
Which strategy is to be used is decided by the generic constructor based on the arguments.

One additional special case might be the \texttt{common} package.
First this was contained in the \texttt{verticalAPI/types} package but as we progressed, we figured it would be a good idea to extract the definition of some message types we use throughout the whole module.
This way we avoid the necessity to include the \texttt{verticalAPI/types} package everywhere.

\begin{landscape}
	\pagestyle{empty}
	\begin{figure}
		\centering
		\hspace*{-0.1\linewidth}\includegraphics[width=1.2\linewidth]{figures/class}
		\caption{Class diagram for the packages included in our project, generated by PlantUML.}
		\label{fig:classDia}
	\end{figure}
\end{landscape}

\subsection{Process architecture}

To explain the current process architecture, we opted to first give a general overview of how the processes are spawned and supposed to communicate through channels. Then we present details on which type of messages can be sent over which channels and finally a few scenarios will be displayed to show how the threads communicate with each other.

\subsubsection{Processes (threads) Creation} \label{process-creation}

\textbf{Main} is the entry point of the whole module. This thread will spawn a \textbf{Listener} \textit{Vertical API} thread that will keep accepting new connection to the module. For each new connection, two new routines are spawned: one that will \textbf{receive} and process messages and one that will \textbf{send} messages. Communication directed to or from routines created by Vertical API happen through respectively with the \textbf{toVert} and \textbf{fromVert} channels.

Then, \textbf{Main} will create the \textbf{Strategy} thread, which will then spawn a \textbf{Listener} thread for the {Horizontal API}. The latter, similarly to the Vertical, will accept new connection ans create for each one two threads, one for reading and one for writing. Communication between Main and Strategy routines happen in the \textbf{fromStrat} and \textbf{toStrat} channels, while Strategy communicates with threads of Horizontal with the \textbf{fromHz} and \textbf{toHz} channels.

As already mentioned, there is actually no communication between Horizontal API goroutines and the Main. The communication can again be seen in figure \ref{fig:overview}. It is important to note that there will actually be multiple channels directed to the Vertical API (toVert), as well as multiple channels directed to the Horizontal API (toHz). This is because incoming messages from the network are aggregated on the same channel while outgoing messages will be sent to specific hosts, so different channels.

\subsubsection{Message Types}

\Todo{figure for message types on different channels}

\subsubsection{Scenario 1: Gossip Notify Message}

The first scenario we want to display is the reception of a Gossip Notification message. For the sake of clarity, a single Vertical API thread is used to show both the writing and reading threads.

In this case the message passing is trivial \ref{fig:msg-notify}. The Vertical API receive the message, marshal it and send it to the main thread where the Gossip Type will be registered. It's interesting to notice that what we store is the writing communication channel. As previously mentioned \ref{process-creation}, there are multiple writing channels, one for each hosts. This will greatly simplify the sending procedure.

\begin{figure}
	\centering
	\input{figures/msgpass-notify}
	\caption{Message passing when a Gossip Notify message is received}
	\label{fig:msg-notify}
\end{figure}

\subsubsection{Scenario 2: Peer Relayed a Message}

\begin{figure}
	\centering
	\input{figures/msgpass-relay}
	\caption{Message passing when a Gossip Notify message is received}
	\label{fig:msg-relay}
\end{figure}


\subsubsection{Scenario 3: Gossip Announce Message}


\Todo{come up with scenario (reg, announce \quad|\quad notify > validation) to explain message-passing}



% \begin{figure}
% 	\centering
% 	\input{figures/fsm_msgs}
% 	\caption{Finite state machine for message caching.}
% 	\label{fig:fsm_msgs}
% \end{figure}

threading, multi-process, ... (a lot of intersection with the classes, but I think here we can go in depth about the communication part)

\subsection{Networking} \label{sec:structureNetworking}

For the networking, first we need to differentiate between the two APIs our module has.
First, the verticalAPI and second the horizontalAPI.

\subsubsection{verticalAPI}
On the verticalAPI we communicate with other modules typically running on the same peer.
At this point, these modules are implemented by someone else (\eg another team in the lecture).
Therefore, we were handed a specification which defines the format of the messages on that API.
With the hard requirement to adhere to this specification it is not possible for us to use capnproto at this point, so we need to implement the de-\,/\,parsing on our own.
If you have a look back at the class diagram in \cref{fig:classDia} again, this is implemented in the \texttt{verticalAPI/types} package.

\subsubsection{horizontalAPI}
On the other side we have the horizontalAPI which is only used for our module to communicate with the same module running on another peer.
As a result, we are completely free to come up with a custom message format on this API.
In our case we decided to use capnproto as a library which does the de-\,/\,parsing for us.
Analog to the verticalAPI, the code generated by capnproto is placed in the \texttt{horizontalAPI/types} package.

\subsubsection{both API-modules}
Apart from the difference in the message formats and the de-\,/\,parsing both, the horizontalAPI and the verticalAPI, modules are quite similar.
Both modules use two threads, one for reading from and one for writing to the socket, per connection in addition to the one thread used to establish (and dispatch) new connections.
Thereby, they both provide a layer of abstraction on top of the raw TCP sockets where other threads can simply send a message on the respective golang channel and (try to) receive from the golang channel in the other direction.

Especially for reading having the golang channel is nice since we can make use of golang's built-in \texttt{select} statement when waiting for messages on multiple interfaces.
For writing this approach is not strictly necessary.
Still having a dedicated thread and the golang channel for communication allows us to send the message to the API-module and continue execution without waiting until the message actually was sent on the network connection.

In general this architecture also allows us to have multiple listening (read) and multiple writing threads connected to the API-module.
Since we did not need it so far, we did not implement having multiple listening threads.
Also note how this use of one thread per read\,/\,write on the connection combined with the communication via golang channels implicitly synchronizes the write operations (although in golang this is not strictly necessary to be done manually).


\section{Security Measures}
% TODO(Fabio)

\Todo{not in place, but put some thought into it (PoW for participation) \tos \cf future work}

E.g secure channels between peers, sybil resistance mechanism, concurrent lookup paths in DHT protocol, . . . 

You should briefly describe the intention behind the security measure and how you want to implement it


\section{Specification of the peer-to-peer protocol}
This module works with two protocol, one on the verticalAPI and one on the horizontalAPI.
The one for the verticalAPI was already predetermined, its specification can be found in the \emph{specification.pdf} document.
For the other one we had the freedom to develop something on our own.
To avoid having to write the de-\,/\,parsing ourselves, we chose to use capnproto.
Capnproto is a data serialization format which comes with libraries in multiple different languages.
With capnproto you only specify what data (\enquote{name} and type) should be in the message.
The concrete message format is then the concern of capnproto.

With this in mind, it makes no real sense to include the concrete format of the messages but only the names of the fields and their type.
As of now we only have one message type on the horizontalAPI, namely the \emph{push} message type.
Its fields and types can be seen in \cref{tab:push}.
This message type is used to actively send information to the neighboring peers.

The actual message sent on the horizontalAPI is not the raw \emph{push} message type but a more generic message type which is a simple union of all message types that can be sent on the horizontalAPI.
At the moment there is only the \emph{push} message type but having in mind what we have planned, we will need more in the future (\cref{sec:future})
This approach makes is possible to add more message types as we go by simply adding more types to this union.
The nice thing at this point is that capnproto handles the complete checking which message type was actually sent (resolving the union so to speak).
This way we do not need to come up with \eg a messageType field on our own and assign identifiers for the individual types.

\begin{table}
	\centering
	\input{figures/hzMsgs_push}
	\caption{Contents of a push message.}
	\label{tab:push}
\end{table}

\section{Future Work} \label{sec:future}
\begin{itemize}
	\item currently only unit tests \tos end to end tests would be nice to test if everything works well together. Plan on using a simple network (for which we can make assumptions which nodes should/have to receive the message), start up the peers and instruct one node on the verticalAPI to spread a message
	\item this end to end testing already lays the foundation for larger scale benchmarking of our gossip strategy (test different parameters, use a much larger (randomly generated but fixed for reproducibility) network)
	\item push is not the only strategy which can be used for gossip, we also plan on implementing a pull strategy (which we can benchmark as well and compare the results)
	\item currently no security measures in place, but we plan on implementing one
		\begin{itemize}
			\item when connecting peers have to solve a PoW challenge (sent by the remote peer)
			\item first step in mitigating against sybil attack because attacker is limited by ressources how many peers can join the network (at once). BUT attacker might add nodes one by one and thereby kinda share time-multiplex the resource
			\item a peer might (and should) request new PoW periodically
			\item thereby this ties the upper limit of sybils an attacker can insert into the network to the resources the attacker can allocate for its sybils at the same (at least kinda same) time
			\item periodical PoW might be used to DoS a node by requesting PoW over and over again. Thus, nodes should keep track of the point in time of the last PoW request of a neighbor to detect this.
			\item When PoW fails or times out, the connection is silently closed (keeping the connection open but the node does not send/receive data from the connection anymore)
			\item If there still is time left we intend to optimize the PoW further so that a node is not overwhelmed by too many PoW requests
		\end{itemize}
\end{itemize}
% TODO do a subsection for the security part if we go into detail here
% TODO(Lukas)

\section{Workload distribution}
As already outlined, we split our module in various different packages.
This enabled us to distribute the packages and work independently of each other (apart from defining the communication\,/\,interface of course).

% TODO(Fabio)
\Todo{Fabio: strategy (peer programming), vertAPI (testing), main (both)}

Lukas worked on the horizontalAPI and the verticalAPI (from which the common package later was derived).
Note that at least writing the de-\,/\,parsing of the verticalAPI was pretty straight forward because it is fairly similar to what we needed to do for the registration client.

While Fabio started working on the main package, Lukas later did some refactoring and finalized the package.


\todos

\end{document}
